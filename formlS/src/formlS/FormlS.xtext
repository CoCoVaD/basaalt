grammar formlS.FormlS with org.eclipse.xtext.common.Terminals
// This grammar specifies only the FormL syntax

generate formlS "http://www.FormlS.formlS"

MockUp:
	// A mock-up is a sequence of models, with at least one model
	comments += STRING*
	models+=Model+
	comments += STRING*
;
	
// ========== Model ==================================================
Model:
	// A model is composed of a model declaration, possibly combined
	// with a model definition block, and possibly followed by statements 
	// contributing to the definition of the model
	ModelDeclaration (DefinitionBlock | ';')
	statements+=Statement*
;

fragment ModelDeclaration:
	'Model' name=ID 
	comments += STRING*
	('extends' extended+=[Model] (',' extended+=[Model])*)?
	comments += STRING*
;

fragment DefinitionBlock:
	':' statements+=Statement
|	'begin' statements+=Statement* 'end' (endName=ID)? ';'
;	

fragment GlobalDefinition:
	'is' value=INT ';'
;

Statement:
	sectionDecl=Section
|	classDecl=DefinedClass
|	objectDecl=Object
//|	contractDecl=Contract
//|	encroachmentDecl=Encroachment
//|	tlDecl=TempotalLocator
|	sectionDef=SectionDefinition
//|	itemDecl=Item
|	itemDef=GlobalObjectDefinition
//|	inst=Instruction
;


// ========== Section ==================================================
Section:
	'Section' name=ID
	comments+=STRING*
	(DefinitionBlock | ';')
;

SectionDefinition:
	id=[Section]
	DefinitionBlock
;
 
// ========== Class ===========================================
PredefinedClass:
	'Boolean' | 'Integer' | 'Real' | 'String'
|	'Event'
|	'Property' | 'Assumption' | 'Objective' | 'Requirement' | 'Guarantee' | 'Guard'
|	'Object'
;

DefinedClass:
	((private?='private' | main?='main' | external?='external')? & (abstract?='abstract')?)
	('Class' | enumeration?='Enumeration' states=States comments+=STRING*) 
	Determiner? name=ID
	mySetIndication=SetIndication?
	Parameters?
	comments+=STRING*
	('extends' extended+=Class (',' extended+=Class)*)?
	comments += STRING*
	';'
;

States:
	'[' states+=State ((',' states+=State)+ | ('&' states+=State)+) ']'
;

State:
	(enumeration=[DefinedClass] | states=States)? id=ID comments+=STRING*
;

Class:
	(definedClass=[DefinedClass] Arguments? | predefinedClass=PredefinedClass) setIndication=SetIndication?
;

fragment Determiner:
	determiner=('!' | '#' | '@' | '^' | '~' | '?')
;

fragment Variability:
	(fixed?='fixed' | constant?='constant')
;

fragment Cardinal:
	ln=Expression ('..' (ub=Expression | infinity?='%'))?
;

fragment Parameters:
	'(' parameters+=Parameter (',' parameters+=Parameter)* ')'
;

Parameter:
	class=Class 
	Determiner? id=ID 
	comments+=STRING*
;

fragment Arguments:
	'(' arguments+=Expression (',' arguments+=Expression)* ')'
;

Expression:
	value=INT	// temporary
;

SetIndication:
	{SetIndication} domain?='$'? '{' (Determiner? & Variability? & Cardinal?) '}'
;

// ========== Object =================================================
Object:
 	(	main?='main'
	|	external?='external'? & private?='private'? & common?='common'? & Variability?
	)
	(classes+=Class | '(' classes+=Class (',' classes+=Class)* ')')
	Determiner? name=ID
	comments += STRING*
	Parameters?
	comments+=STRING*
	(DefinitionBlock | GlobalDefinition | ';')
;

GlobalObjectDefinition:
	// This is ugly, but it seems that Xtext parsing cannot make 
	// the difference between references of different types
	Determiner id=[Object] (DefinitionBlock | GlobalDefinition)
|	id=[Object] GlobalDefinition 
;
