grammar forml.Forml with org.eclipse.xtext.common.Terminals

generate forml "http://www.Forml.forml"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Models:
	models+=Model+
	// Verify one and only one Model (the Root Model) is not extended
;
	
Model:
	'Model' name=ID comments+=STRING*
	('extends' extendedModels+=ExtendedModel (',' extendedModels+=ExtendedModel)*)? 
	(	':' statements+=Statement
	|	 'begin' statements+=Statement* blockEnd?='end' endName=ID? ';' 
	|	';'
	)	statements+=Statement*
	/// Verify that Model is not in extension closure
	/// Warning if 'name' begins with a lower case, with a quick fix
	/// Warning if 'name' begins with a ° or an _
	/// Warning if a begin-end block is not provided with an 'endName', with a quick fix
	/// Verify that if a begin-end block is provided with an 'endName', 
	/// 	it is equal to 'name', with a quick fix
;

ExtendedModel:
	model=[Model] comments+=STRING*
;

Statement:
(	partialModel=PartialModel
|	definedClass=DefinedClass
|	object=Object
|	partialModelDefinition=PartialModelDefinition
|	classDefinition=ClassDefinition
|	objectDefinition=ObjectDefinition
//|	acknowledgment=Acknowledgment
)	comments+=STRING*
;

PartialModel:
	'partial' 'Model' name=ID comments+=STRING*
	(	':' statements+=Statement
	|	 'begin' statements+=Statement* blockEnd?='end' endName=ID? ';' 
	|	';'
	)	
	/// Warning if 'name' begins with a lower case, with a quick fix
	/// Warning if 'name' begins with a °
	/// Warning if a begin-end block is not provided with an 'endName', with a quick fix
	/// Verify that if a begin-end block is provided with an 'endName', 
	/// 	it is equal to 'name', with a quick fix
;

PartialModelDefinition:
	'refined' 'partial' 'model' item=[PartialModel | QualifiedName] comments+=STRING*
	(	':' statements+=Statement
	|	 'begin' statements+=Statement* blockEnd?='end' endName=ID? ';' 
	)
	// Warning if a begin-end block is not provided with an 'endName', with a quick fix
	// Verify that if a begin-end block is provided with an 'endName', 
	// 	it is equal to 'item.name', with a quick fix
;

DefinedClass:
	((main?='main' | external?='external')? & (private?='private')? & (abstract?='abstract')?)
	(normalClass?='Class' | enumeration?='Enumeration' states=States)
//|	quantityClass=QuantityClass
//|	setClass=SetClass
	(determiner=Determiner)? name=ID comments+=STRING*
	('extends' extendedClasses+=ExtendedClass (',' extendedClasses+=ExtendedClass)*)? 
	(	':' statements+=Statement
	|	 block?='begin' statements+=Statement* blockEnd?='end' endName=ID? ';' 
	|	';'
	)
	/// Verify that 'name' is not in the closure of 'extendedClasses'
	/// Warning if 'name' begins with a lower case, with a quick fix
	/// Warning if 'name' begins with a ° or an _
	/// Warning if a begin-end block is not provided with an 'endName', with a quick fix
	/// Verify that if a begin-end block is provided with an 'endName', 
	/// 	it is equal to 'name', with a quick fix
	//  Verify that 'statements' does not contain any partial model
;

ClassDefinition:
	'refined' 'class' item=[DefinedClass | QualifiedName] comments+=STRING*
	(	':' statements+=Statement
	|	 'begin' statements+=Statement* blockEnd?='end' endName=ID? ';' 
	)
	// Warning if a begin-end block is not provided with an 'endName', with a quick fix
	// Verify that if a begin-end block is provided with an 'endName', 
	// 	it is equal to 'item.name', with a quick fix
;

Determiner: '#' | '@' | '~' | '^' | '!' | '?';

PredefinedClass:
	'Boolean'  | 'Integer'    | 'Real'      | 'String'      | 'Event'
|	'Property' | 'Assumption' | 'Objective' | 'Requirement' | 'Guarantee'
|	'Guard'    | 'Object'
;

ExtendedClass:
(	preDefinedClass=PredefinedClass
|	definedClass=[DefinedClass]
)	comments+=STRING*
;

States:
	'[' states+=State
(	list?=',' states+=State (',' states+=State)* 
|	product?='&' states+=State ('&' states+=State)+
)	']'
;

State:
(	states=States 				// Composite state on the fly
|	enumeration=[DefinedClass]			// Composite state on existing enumeration
)?	name=ID
	comments+=STRING*
	// Verify that the 'DefinedClass' is an Enumeration
;
 
Object:
	(main?='main'? | (external?='external'? & private?='private'? & (constant?='constant' | fixed?='fixed')?))
	class=Classes
	(determiner=Determiner)? name=ID
	comments+=STRING*
	(	is?='is' value=Value ';' valueComments+=STRING*
	|	':' statements+=Statement
	|	 block?='begin' statements+=Statement* blockEnd?='end' endName=ID? ';' 
	|	';'
	)
	/// Warning if 'name' begins with an upper case, with a quick fix
	/// Warning if a begin-end block is not provided with an 'endName', with a quick fix
	/// Verify that if a begin-end block is provided with an 'endName', 
	/// 	it is equal to 'name', with a quick fix
	// Verify that the same 'name' is not declared with different types
	//  Verify that 'statements' does not contain any partial model
;

Classes:
	classes+=ClassOfObject (',' classes+=ClassOfObject)*
;

ClassOfObject:
(	preDefined=PredefinedClass
|	definedClass=[DefinedClass]
)	comments+=STRING*
;

ObjectDefinition:
	'refined' 'object' item=[Object | QualifiedName] comments+=STRING*
	(	':' statements+=Statement
	|	 'begin' statements+=Statement* blockEnd?='end' endName=ID? ';' 
	)
	// Warning if a begin-end block is not provided with an 'endName', with a quick fix
	// Verify that if a begin-end block is provided with an 'endName', 
	// 	it is equal to 'item.name', with a quick fix
;

Value:
	{Value} true?='true'?
|	{Value} false?='false'?
|	{Value} real=Float?
|	{Value} string=STRING?
|	{Value} reference=[Object | QualifiedName]?
;

Float hidden():  
(	whole=INT ('.' (decimal=INT | exp=EXPONENT)?)?
|	'.' (decimal=INT | exp=EXPONENT)
|	exp=EXPONENT
)
;

QualifiedName hidden(): ID('.' ID)*;

@Override
terminal ID: ('a'..'z'|'A'..'Z'|'°') ('a'..'z'|'A'..'Z'|'_'|'°'|'0'..'9')*;

terminal EXPONENT: ('0'..'9')+ ('E' | 'e') ('+' | '-')? ('0'..'9')+;

@Override
terminal INT returns ecore::EInt: ('0'..'9')+;


