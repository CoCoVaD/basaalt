grammar forml.Forml with org.eclipse.xtext.common.Terminals

generate forml "http://www.Forml.forml"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// 24 January 2025

Models:
	models+=Model*
	// If the list is not empty, verify one and only one 
	// Model (the Root Model) is not extended
;
	
Model:
	'Model' 
	name=ID 
	comments+=STRING*
	('extends' extendedModels+=ExtendedModel (',' extendedModels+=ExtendedModel)*)? 
	(	':' statements+=ModelStatement
	|	 block?='begin' statements+=ModelStatement* 'end' endName=ID? ';' 
	|	';'
	)
	/// Verify that Model is not in extension closure
	/// Warning if 'name' begins with a lower case, with a quick fix
	/// Warning if 'name' begins with a ° or an _
	/// Warning if a begin-end block is not provided with an 'endName', with a quick fix
	/// Verify that if a begin-end block is provided with an 'endName', 
	/// 	it is equal to 'name', with a quick fix
;

ExtendedModel:
	model=[Model]
	comments+=STRING*
;

ModelStatement:
(	partialModel=PartialModel	
|	class=Class
|	object=Object
//|	contract=Contract
//|	instruction=Instruction
)	comments+=STRING*
;

PartialModel:
	'partial' 'Model' 
	name=ID 
	comments+=STRING*
	(	':' statements+=ModelStatement
	|	 block?='begin' statements+=ModelStatement* 'end' endName=ID? ';' 
	|	';'
	)
	/// Warning if 'name' begins with a lower case, with a quick fix
	/// Warning if 'name' begins with a ° or an _
	/// Warning if a begin-end block is not provided with an 'endName', with a quick fix
	/// Verify that if a begin-end block is provided with an 'endName', 
	/// 	it is equal to 'name', with a quick fix
;

Class:
	preDefinedClass=PredefinedClass
|	definedClass=DefinedClass
;

Determiner: '#' | '@' | '~' | '^' | '!' | '?';

PredefinedClass:
	'Boolean'  | 'Integer'    | 'Real'      | 'String'      | 'Event'
|	'Property' | 'Assumption' | 'Objective' | 'Requirement' | 'Guarantee'
|	'Guard'    | 'Object'
;

DefinedClass:
	((main?='main' | external?='external')? & (private?='private')? & (abstract?='abstract')?)
	(definedClass?='Class' | enumeration?='Enumeration' states=States)
//|	quantityClass=QuantityClass
//|	setClass=SetClass
	(determiner=Determiner)? name=ID
	comments+=STRING*
	('extends' extendedClasses+=ExtendedClass (',' extendedClasses+=ExtendedClass)*)? 
	(	':' statements+=ClassStatement
	|	 block?='begin' statements+=ClassStatement* 'end' endName=ID? ';' 
	|	';'
	)
	//  Verify that 'name' is not in the closure of 'extendedClasses'
	/// Warning if 'name' begins with a lower case, with a quick fix
	/// Warning if 'name' begins with a ° or an _
	/// Warning if a begin-end block is not provided with an 'endName', with a quick fix
	/// Verify that if a begin-end block is provided with an 'endName', 
	/// 	it is equal to 'name', with a quick fix
;

ExtendedClass:
(	preDefinedClass=PredefinedClass
|	definedClass=[Class]
)	comments+=STRING*
;

States:
	'[' states+=State
(	list?=',' states+=State (',' states+=State)* 
|	product?='&' states+=State ('&' states+=State)+
)	']'
;

State:
(	states=States 				// Composite state on the fly
|	enumeration=[DefinedClass]	// Composite state on existing enumeration
)?	name=ID
	comments+=STRING*
	// Verify that the 'DefinedClass' is an Enumeration
;

ClassStatement:
(	class=Class
|	object=Object
//|	contract=Contract
//|	instruction=Instruction
)	comments+=STRING*
;
 
Object:
	(main?='main'? | (external?='external'? & private?='private'? & (constant?='constant' | fixed?='fixed')?))
	class=ObjectClasses
	(determiner=Determiner)? name=ID
	comments+=STRING*
	('is' value=Value)?
	';'
	// Verify that the same 'name' is not declared with different types
	/// Warning if 'name' begins with an upper case, with a quick fix
;


ObjectClasses:
	classes+=ObjectClass (',' classes+=ObjectClass)*
;

ObjectClass:
(	preDefined=PredefinedClass
|	definedClass=[DefinedClass]
)	comments+=STRING*
;

Value:
	{Value} true?='true'?
|	{Value} false?='false'?
|	{Value} real=Float?
|	{Value} string=STRING?
;

Float:  
(	whole=INT ('.' (decimal=INT | exp=EXPONENT)?)?
|	'.' (decimal=INT | exp=EXPONENT)
|	exp=EXPONENT
)
;

@Override
terminal ID: ('a'..'z'|'A'..'Z'|'_'|'°') ('a'..'z'|'A'..'Z'|'_'|'°'|'0'..'9')*;

terminal EXPONENT: ('0'..'9')+ ('E' | 'e') ('+' | '-')? ('0'..'9')+;

@Override
terminal INT returns ecore::EInt: ('0'..'9')+;


