/*
 * generated by Xtext 2.37.0
 */
package forml.validation

import org.eclipse.xtext.validation.Check
import static extension java.lang.Character.*
import java.util.HashSet
import forml.forml.FormlPackage
import forml.forml.Model
import forml.forml.PartialModel
import forml.forml.DefinedClass
import forml.forml.Object

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */


class FormlValidator extends AbstractFormlValidator {
	
	protected static val ISSUE_PREFIX = 'forml.'

/**
 * Name 
 *
 */
	public static val INCORRECT_MODEL_NAME = ISSUE_PREFIX + "IncorrectModelName"
	@Check
	def checkModelNameStartsWithUppercase (Model model) {
		val char degree     = '°'	// This is necessary to prevent Xtext from
		val char underscore = '_'	// converting char literals into strings
		if (model.name.charAt(0) == degree || model.name.charAt(0) == underscore)
			warning(
				"Model names should begin neither with a ° nor with an _", 
				FormlPackage.eINSTANCE.model_Name,
				INCORRECT_MODEL_NAME,
				model.name)
	}

	public static val UNCAPITALIZED_MODEL_NAME = ISSUE_PREFIX + "UncapitalizedModelName"
	@Check
	def checkModelNameDoesNotStartsWithLowercase (Model model) {
		if (model.name.charAt(0).lowerCase)
			warning(
				"Model names should not begin with a lower case letter", 
				FormlPackage.eINSTANCE.model_Name,
				UNCAPITALIZED_MODEL_NAME,
				model.name)
	}

	public static val INCORRECT_PARTIAL_MODEL_NAME = ISSUE_PREFIX + "IncorrectPartialModelName"
	@Check
	def checkPartialModelNameStartsWithUppercase (PartialModel partialModel) {
		val char degree     = '°'	// This is necessary to prevent Xtext from
		val char underscore = '_'	// converting char literals into strings
		if (partialModel.name.charAt(0) == degree || partialModel.name.charAt(0) == underscore)
			warning(
				"Partial model names should begin neither with a ° nor with an _", 
				FormlPackage.eINSTANCE.partialModel_Name,
				INCORRECT_PARTIAL_MODEL_NAME,
				partialModel.name)
	}

	public static val UNCAPITALIZED_PARTIAL_MODEL_NAME = ISSUE_PREFIX + "UncapitalizedPartialModelName"
	@Check
	def checkPartialModelNameDoesNotStartWithLowercase (PartialModel partialModel) {
		if (partialModel.name.charAt(0).lowerCase)
			warning(
				"Partial model names should not begin with a lower case letter", 
				FormlPackage.eINSTANCE.partialModel_Name,
				UNCAPITALIZED_PARTIAL_MODEL_NAME,
				partialModel.name)
	}


	public static val INCORRECT_CLASS_NAME = ISSUE_PREFIX + "IncorrectClassName"
	@Check
	def checkClassNameStartsWithUppercase (DefinedClass definedlass) {
		val char degree     = '°'	// This is necessary to prevent Xtext from
		val char underscore = '_'	// converting char literals into strings
		if (definedlass.name.charAt(0) == degree || definedlass.name.charAt(0) == underscore)
			warning(
				"Class names should begin neither with a ° nor with an _", 
				FormlPackage.eINSTANCE.definedClass_Name,
				INCORRECT_CLASS_NAME,
				definedlass.name)
	}
	public static val UNCAPITALIZED_CLASS_NAME = ISSUE_PREFIX + "UncapitalizedClassName"
	@Check
	def checkClassNameDoesNotStartWithLowercase (DefinedClass definedClass) {
		if (definedClass.name.charAt(0).lowerCase)
			warning(
				"Class names should not begin with a lower case letter", 
				FormlPackage.eINSTANCE.definedClass_Name,
				UNCAPITALIZED_CLASS_NAME,
				definedClass.name)
	}

	public static val INCORRECT_OBJECT_NAME = ISSUE_PREFIX + "IncorrectObjectName"
	@Check
	def checkObjectNameDoesNotStartsWithUppercase (Object object) {
		if (object.name.charAt(0).upperCase)
			warning(
				"Object names should not begin with an upper case letter", 
				FormlPackage.eINSTANCE.object_Name,
				INCORRECT_OBJECT_NAME,
				object.name)
	}

/**
 * No end name
 *
 */
	public static val NO_MODEL_END_NAME = ISSUE_PREFIX + "NoModelEndName"
	@Check
	def checkModelEndNameExists(Model model) {
		if (model.block)
			if (model.endName === null)
				warning(
					"No end name", 
					FormlPackage.eINSTANCE.model_BlockEnd,
					NO_MODEL_END_NAME,
					model.name)
	}
	
	public static val NO_PARTIAL_MODEL_END_NAME = ISSUE_PREFIX + "NoPartialModelEndName"
	@Check
	def checkPartialModelEndNameExists(PartialModel partialModel) {
		if (partialModel.block)
			if (partialModel.endName === null)
				warning(
					"No end name", 
					FormlPackage.eINSTANCE.partialModel_BlockEnd,
					NO_PARTIAL_MODEL_END_NAME,
					partialModel.name)
	}
	
	public static val NO_CLASS_END_NAME = ISSUE_PREFIX + "NoClassEndName"
	@Check
	def checkClassEndNameExists(DefinedClass definedClass) {
		if (definedClass.block)
			if (definedClass.endName === null)
				warning(
					"No end name", 
					FormlPackage.eINSTANCE.definedClass_BlockEnd,
					NO_CLASS_END_NAME,
					definedClass.name)
	}
	
	public static val NO_OBJECT_END_NAME = ISSUE_PREFIX + "NoObjectEndName"
	@Check
	def checkObjectEndNameExists(Object object) {
		if (object.block)
			if (object.endName === null)
				warning(
					"No end name", 
					FormlPackage.eINSTANCE.object_BlockEnd,
					NO_OBJECT_END_NAME,
					object.name)
	}

/**
 * End name different from name 
 *
 */
	public static val INCORRECT_MODEL_END_NAME = ISSUE_PREFIX + "IncorrectModelEndName"
	@Check
	def checkModelEndName(Model model) {
		if (model.block)
			if (model.endName != model.name)
				error(
					"End name (" + model.endName + ") different from name (" + model.name +")", 
					FormlPackage.eINSTANCE.model_EndName,
					INCORRECT_MODEL_END_NAME,
					model.name,
					model.endName)
	}

	public static val INCORRECT_PARTIAL_MODEL_END_NAME = ISSUE_PREFIX + "IncorrectPartialModelEndName"
	@Check
	def checkPartialModelEndName(PartialModel partialModel) {
		if (partialModel.block)
			if (partialModel.endName != partialModel.name)
				error(
					"End name (" + partialModel.endName + ") different from name (" + partialModel.name +")", 
					FormlPackage.eINSTANCE.partialModel_EndName,
					INCORRECT_PARTIAL_MODEL_END_NAME,
					partialModel.name,
					partialModel.endName)
	}

	public static val INCORRECT_CLASS_END_NAME = ISSUE_PREFIX + "IncorrectClassEndName"
	@Check
	def checkClassEndName(DefinedClass definedClass) {
		if (definedClass.block)
			if (definedClass.endName != definedClass.name)
				error(
					"End name (" + definedClass.endName + ") different from name (" + definedClass.name +")", 
					FormlPackage.eINSTANCE.definedClass_EndName,
					INCORRECT_CLASS_END_NAME,
					definedClass.name,
					definedClass.endName)
	}

	public static val INCORRECT_OBJECT_END_NAME = ISSUE_PREFIX + "IncorrectObjectEndName"
	@Check
	def checkOjectEndName(Object object) {
		if (object.block)
			if (object.endName != object.name)
				error(
					"End name (" + object.endName + ") different from name (" + object.name +")", 
					FormlPackage.eINSTANCE.object_EndName,
					INCORRECT_OBJECT_END_NAME,
					object.name,
					object.endName)
	}

/**
 * Extension cycles 
 *
 */
	def void collectExtendedModels(HashSet<Model> collectedModels, HashSet<Model> visitedModels, Model m) {
		if (!visitedModels.contains(m)) {
			visitedModels.add(m)
			if (!collectedModels.contains(m)) collectedModels.add(m)
			if (m.extendedModels !== null)
				for (extendedModel : m.extendedModels) 
					collectExtendedModels(collectedModels, visitedModels, extendedModel.model)
		}		
	}
 
	@Check
	def checkModelNotInExtensionClosure(Model m) {
		if (m.extendedModels === null)
			return // nothing to check
			
		val HashSet<Model> collectedModels = newHashSet
		val HashSet<Model> visitedModels = newHashSet
		for (extendedModel : m.extendedModels) 
			collectExtendedModels(collectedModels, visitedModels, extendedModel.model)
		
		if (collectedModels.contains(m)) 
			error(
				"Cycle in hierarchy extension of model '" + m.name + "'",
				FormlPackage.eINSTANCE.model_ExtendedModels)
	}
	
	def void collectExtendedClasses(HashSet<DefinedClass> collectedClasses, HashSet<DefinedClass> visitedClasses, DefinedClass c) {
		if (!visitedClasses.contains(c)) {
			visitedClasses.add(c)
			if (!collectedClasses.contains(c)) collectedClasses.add(c)
			if (c.extendedClasses !== null)
				for (extendedClass : c.extendedClasses) 
					if (extendedClass.definedClass !== null)
						collectExtendedClasses(collectedClasses, visitedClasses, extendedClass.definedClass)
		}		
	}
 
	@Check
	def checkClasslNotInExtensionClosure(DefinedClass c) {
		if (c.extendedClasses === null)
			return // nothing to check
			
		val HashSet<DefinedClass> collectedClasses = newHashSet
		val HashSet<DefinedClass> visitedClasses = newHashSet
		for (extendedClass : c.extendedClasses) 
			collectExtendedClasses(collectedClasses, visitedClasses, extendedClass.definedClass)
		
		if (collectedClasses.contains(c)) 
			error(
				"Cycle in hierarchy extension of class '" + c.name + "'",
				FormlPackage.eINSTANCE.definedClass_ExtendedClasses)
	}
}
